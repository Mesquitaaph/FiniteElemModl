# -*- coding: utf-8 -*-
"""Elementos Finitos - Vetorizacao.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HdZdbcdy7VcjdY5jThq7WBicQgS0U52R

using GaussQuadrature

run(`clear`)

# x, w = legendre(5)

function PHI(P)
    return [(1-P)/2 (1+P)/2]
end

function dPHI(P)
    return [-1/2*(P^0) 1/2*(P^0)]
end

function montaK(ne, dx, alpha, beta)
    npg = 2; P, W = legendre(npg)

    phiP = PHI.(P); dphiP = dPHI.(P')
    println(dphiP)
    # print(dphiP)
    Ke = 2*alpha/dx * (W.*dphiP) * dphiP' + beta*dx/2 * (W.*phiP) * phiP'

    return Ke
end

alpha = 1; beta = 1; ne = 1; dx = 1/4
K = montaK(ne, dx, alpha, beta)

# tst = [1 -1]
"""
from sys import getsizeof
import time
import math
import numpy as np
import matplotlib.pyplot as plt
from numpy.polynomial.legendre import leggauss
from scipy.sparse import linalg
from scipy import sparse

dot_type = 2

def prod(A, B):
  if dot_type == 1:
    return A @ B
  if dot_type == 2:
    return np.dot(A, B)
  if dot_type == 3:
    return np.einsum('ik,kj->ij', A, B)

npg = 5

t0 = 0
tf = 1

PI = math.pi

def exemplos(exemplo):
  if exemplo == 1:
    alpha = 1; beta = 1
    f = lambda x : x
    u = lambda x : x + (np.exp(-x) - np.exp(x))/(np.e - np.exp(-1))

  if exemplo == 2:
    alpha = 1
    beta = 1
    lamda = np.power(PI, 2) + 1
    f = lambda x,t : 0*x**0
    u = lambda x,t : (1/np.power(PI, 2))*np.sin(PI*x)*np.exp(-lamda*t)

  return alpha, beta, f, u

def PHI(P):
  return np.array([
      (1-P)/2,
      (1+P)/2
  ])

def PHIl(P):
  return np.array([
      -1/2*P**0,
      1/2*P**0
  ])

P, W = leggauss(npg)
P = np.array(P); W = np.array(W)

phiP = np.array(PHI(P))
phiPT = phiP.T

dphiP = np.array(PHIl(P))

def montaxPTne(ne, X, P):
  h = 1/ne
  return (h/2)*(P+1)[:,np.newaxis] + X

def montaEQoLG(ne):
  return np.array([
      [ne-1, *np.arange(ne-1)],
      np.arange(ne)
    ])

def montaKM(ne, h, alpha, beta, EQoLG):
  npg = 2; P, W = leggauss(npg)

  phiP = PHI(P); dphiP = PHIl(P)
  print(ne, h)
  Ke = 2*alpha/h * prod(W*dphiP, dphiP.T) + beta*h/2 * prod(W*phiP, phiP.T)

  S = Ke.reshape(-1).repeat(ne)
  I = EQoLG[[0, 1, 0, 1], :].reshape(-1)
  J = EQoLG[[0, 0, 1, 1], :].reshape(-1)

  K = sparse.coo_matrix((S,(I,J)),shape=(ne,ne)).tocsr()[:-1, :-1]

  # Me = h/2 * prod(W*phiP, phiP.T)
  # S = Me.reshape(-1).repeat(ne)
  # M = sparse.coo_matrix((S,(I,J)),shape=(ne,ne)).tocsr()[:-1, :-1]

  return K#, M

def montaF(ne, h, X, EQoLG, f):
  xPTne = montaxPTne(ne, X, P)

  S = prod(h/2*W*phiP, f(xPTne)).reshape(-1)
  I = EQoLG.reshape(-1)
  # print(xPTne)

  F = np.bincount(I, weights=S, minlength=ne)[:-1]

  return np.asarray(F).reshape(-1), xPTne

def montaFt(ne, h, X, EQoLG, ft, t):
  xPTne = montaxPTne(ne, X, P)
  f = lambda x: ft(x, t)

  S = prod(h/2*W*phiP, f(xPTne)).reshape(-1)
  I = EQoLG.reshape(-1)

  F = np.bincount(I, weights=S, minlength=ne)[:-1]
  return np.asarray(F).reshape(-1), xPTne

def resolve(ne, u, f, alpha, beta):
  h = 1/ne

  EQoLG = montaEQoLG(ne)

  X = np.arange(0,1,h)

  K = montaKM(ne, h, alpha, beta, EQoLG)
  # print(K.toarray())
  F, xPTne = montaF(ne, h, X, EQoLG, f)

  C = linalg.spsolve(K,F)

  return C, X, xPTne, EQoLG

def erroVet(ne, W, xPTne, phiPT, EQoLG, C, u):
  h = 1/ne

  d = np.array([*C, 0])
  
  return np.sqrt(h/2 * np.sum(prod(W, np.square(u(xPTne) - prod(phiPT, d[EQoLG])))))


alpha, beta, f, u = exemplos(1)

# t = time.time()
# C, X, xPTne, EQoLG = resolve(2**2, u, f, alpha, beta)
# print(C)
# elapsed = time.time() - t
# print(elapsed, " segundos")

t = time.time()

M = 2**np.arange(2,24)

H = 1/M

E = np.zeros((len(M), ))

for i in range(len(M)):
  # print("Entrou em i = ", i)

  # resolve(M[i]+1, u, f, alpha, beta)
  Ci, Xi, xPTnei, EQoLGi = resolve(M[i], u, f, alpha, beta)
  E[i] = erroVet(M[i], W, xPTnei, phiPT, EQoLGi, Ci, u)

elapsed = time.time() - t

print("Conclui i = ", i, "em ", elapsed, " segundos")


